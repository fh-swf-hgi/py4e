
Zeichenketten
=============

Eine Zeichenkette ist eine Folge von Einzelzeichen
--------------------------------------------------

\index{Folge}
\index{Einzelzeichen}\index{Character}
\index{Indexoperator}\index{Zugriff, indexbasiert}
\index{Operator!indexbasierter Zugriff}

Eine Zeichenkette (englisch *String*) ist eine Folge einzelner Zeichen (englisch *Character*). Wor können mit dem indexbasierten Zugriffsoperator (auch Klammeroperator genannt) auf einzelne Zeichen zugreifen:

~~~~ {.python}
>>> fruit = 'banana'
>>> letter = fruit[1]
~~~~

\index{Index}
\index{}

Die zweite Anweisung extrahiert das Zeichen an Indexposition 1 aus der Variablen `fruit` und weist es der Variablen `letter` zu.

Der Ausdruck in eckigen Klammern wird als *Index* bezeichnet. Der Index gibt an, auf welches Zeichen in der Sequenz zugegriffen werden soll.

Aber wir bekommen vielleicht nicht das, was wir erwarten:

~~~~ {.python}
>>> print(letter)
a
~~~~

Für die meisten Menschen ist der erste Buchstabe von „Banane“ eigentlich ein „b“, aber nicht „a“. Aber in Python ist der Index ein Offset vom Anfang der Zeichenkette, und der Offset des ersten Buchstabens ist Null.

~~~~ {.python}
>>> letter = fruit[0]
>>> print(letter)
b
~~~~

So ist „b“ der nullte Buchstabe von „Banane“, „a“ der erste und „n“ der zweite Buchstabe.

![String Indexes](height=0.75in@../images/string)

\index{Index!beginnt mit Null}
\index{Null, Index beginnt mit}

Man kann einen beliebigen Ausdruck, einschließlich Variablen und Operatoren, als Index verwenden, aber der Wert des Index muss eine ganze Zahl sein. Sonst erhält man:

\index{Index}
\index{}
\index{Ausnahme!TypeError}
\index{TypeError}

~~~~ {.python}
>>> letter = fruit[1.5]
TypeError: string indices must be integers
~~~~

Länge einer Zeichenkette
------------------------

\index{len (Funktion)}
\index{Funktion!len}

`len` ist eine eingebaute Funktion, die die Anzahl der Zeichen in einer Zeichenkette zurückgibt:

~~~~ {.python}
>>> fruit = 'banana'
>>> len(fruit)
6
~~~~

Um den letzten Buchstaben einer Zeichenkette zu erhalten, könnte man versucht sein, etwas wie das hier zu tun:

\index{Ausnahme!IndexError}
\index{IndexError}

~~~~ {.python}
>>> length = len(fruit)
>>> last = fruit[length]
IndexError: string index out of range
~~~~

Der Grund für den `IndexError` ist, dass es keinen Buchstaben in „banana“ mit dem Index 6 gibt. Da wir bei Null angefangen haben zu zählen, sind die sechs Buchstaben von 0 bis 5 nummeriert. Um das letzte Zeichen zu erhalten, müssen wir 1 von `length` subtrahieren:

~~~~ {.python}
>>> last = fruit[length-1]
>>> print(last)
a
~~~~

Alternativ können wir auch negative Indizes verwenden, die vom Ende der Zeichenkette rückwärts zählen. Der Ausdruck `fruit[-1]` ergibt den letzten Buchstaben, `fruit[-2]` den vorletzten und so weiter.

\index{Index!negativ}
\index{negativer Index}

Traversieren einer Zeichenkette
-------------------------------

\index{Traversieren}
\index{Schleife!Traversieren}
\index{for-Schleife}
\index{Schleife!for}
\index{Traversieren}

Bei vielen Berechnungen wird eine Zeichenkette Zeichen für Zeichen verarbeitet. Oft beginnen sie am Anfang, wählen jedes Zeichen der Reihe nach aus, machen etwas damit und fahren bis zum Ende fort. Dieses Verarbeitungsmuster wird als *Traversierung* bezeichnet. Eine Möglichkeit, eine solche Traversierung zu implementieren, ist eine `while`-Schleife:

~~~~ {.python}
index = 0
while index < len(fruit):
    letter = fruit[index]
    print(letter)
    index = index + 1
~~~~

Diese Schleife durchläuft die Zeichenkette und zeigt jeden Buchstaben einzeln in einer Zeile an. Die Schleifenbedingung ist `index < len(fruit)`, wenn also `index` gleich der Länge der Zeichenkette ist, ist die Bedingung falsch und der Schleifenrumpf wird nicht mehr ausgeführt. Das letzte Zeichen, auf das zugegriffen wird, ist dasjenige mit dem Index `len(fruit)-1`, also das letzte Zeichen in der Zeichenkette.

**Übung 1: Schreiben Sie eine `while`-Schleife, die beim letzten Zeichen in der Zeichenkette beginnt und sich rückwärts bis zum ersten Zeichen in der Zeichenkette vorarbeitet, wobei jeder Buchstabe in einer eigenen Zeile ausgegeben wird, natürlich rückwärts.**

Eine andere Möglichkeit, einen Traversierung zu schreiben, ist mit einer `for`-Schleife:

~~~~ {.python}
for char in fruit:
    print(char)
~~~~

Jedes Mal, wenn die Schleife durchlaufen wird, wird das nächste Zeichen in der Zeichenkette der Variablen `char` zugewiesen. Die Schleife wird fortgesetzt, bis keine Zeichen mehr übrig sind.

Der slice-Operator
------------------

\index{slice-Operator}
\index{Operator!slice}
\index{Index!slice}
\index{Zeichenkette!slice}
\index{slice!Zeichenkette}

Ein Segment einer Zeichenkette wird im Englischen als *Slice* oder *Substring* (deutsch Teilzeichenkette) bezeichnet. Die Auswahl einer Teilzeichenkette funktioniert ähnlich wie die Auswahl eines Zeichens:

~~~~ {.python}
>>> s = 'Monty Python'
>>> print(s[0:5])
Monty
>>> print(s[6:12])
Python
~~~~

Der Operator gibt den Teil der Zeichenkette vom n-ten Zeichen bis zum m-ten Zeichen zurück, einschließlich des ersten, aber *ausschließlich* des letzten Zeichens.

Wenn man den ersten Index (vor dem Doppelpunkt) weglässt, beginnt die Teilzeichenkette am Anfang der Zeichenkette. Wenn man den zweiten Index ebenfalls weglässt, geht die Teilzeichenkette bis zum Ende der Zeichenkette:

~~~~ {.python}
>>> fruit = 'banana'
>>> fruit[:3]
'ban'
>>> fruit[3:]
'ana'
~~~~

Wenn der erste Index größer oder gleich dem zweiten ist, ist das Ergebnis eine *leere Zeichenkette*, dargestellt durch zwei Anführungszeichen:

\index{Anführungszeichen}

~~~~ {.python}
>>> fruit = 'banana'
>>> fruit[3:3]
''
~~~~

Eine leere Zeichenkette enthält keine Zeichen und hat die Länge 0, aber ansonsten verhält sie sich genauso wie jede andere Zeichenkette.

**Übung 2: Wenn `fruit` eine Zeichenkette ist, was bewirkt dann `fruit[:]`?**

\index{Kopieren!slice}
\index{slice!Kopieren}

Zeichenketten sind unveränderlich
---------------------------------

\index{Veränderbarkeit}
\index{Unveränderlichkeit}
\index{Zeichenkette!unveränderlich}

Es ist verlockend, den Operator auf der linken Seite einer Zuweisung zu verwenden, mit der Absicht, ein Zeichen in einer Zeichenkette zu ändern. Zum Beispiel:

\index{TypeError}
\index{Ausnahme!TypeError}

~~~~ {.python}
>>> greeting = 'Hello, world!'
>>> greeting[0] = 'J'
TypeError: 'str' object does not support item assignment
~~~~

Das „Objekt“ ist in diesem Fall die Zeichenkette und das „Element“ ist das Zeichen, das wir versucht haben zuzuweisen. Im Moment ist ein *Objekt* dasselbe wie ein Wert, aber wir werden diese Definition später verfeinern. Ein *Element* ist einer der Werte in einer Sequenz.

\index{Objekt}
\index{Elementzuweisung}
\index{Zuweisung!Element}
\index{Unveränderlichkeit}

Der Grund für den Fehler ist, dass Zeichenketten *unveränderlich* sind. Dies bedeutet, dass wir eine vorhandene Zeichenkette nicht ändern können. Das Beste, was wir tun können, ist, eine neue Zeichenfolge zu erstellen, die eine Variation der ursprünglichen Zeichenfolge ist:

~~~~ {.python}
>>> greeting = 'Hello, world!'
>>> new_greeting = 'J' + greeting[1:]
>>> print(new_greeting)
Jello, world!
~~~~

In diesem Beispiel wird ein neuer Anfangsbuchstabe an ein Stück von `greeting` angehängt. Es hat keine Auswirkung auf die ursprüngliche Zeichenfolge.

\index{Konkatenation}

Zählen mit Schleifen
--------------------

\index{Schleifenzähler}
\index{Zählen mit Schleifen}
\index{Schleifen und Zählen}
\index{Schleife!mit Zeichenketten}\index{Iteration!durch Zeichenketten}

Das folgende Programm zählt, wie oft der Buchstabe „a“ in einer Zeichenkette vorkommt:

~~~~ {.python}
word = 'banana'
count = 0
for letter in word:
    if letter == 'a':
        count = count + 1
print(count)
~~~~

Dieses Programm demonstriert ein Vorgehen, das man als *Zähler* bezeichnet könnte. Die Variable `count` wird mit 0 initialisiert und dann jedes Mal inkrementiert, wenn ein `'a'` gefunden wird. Wenn die Schleife beendet wird, enthält `count` das Ergebnis: die Gesamtzahl der „a's“.

\index{Auslagern von Code in Funktionen}

**Übung 3: Lagern Sie diesen Code in eine Funktion namens `count` aus, und verallgemeinern Sie diese so, dass sie die Zeichenkette und den Buchstaben als Argumente akzeptiert.**

Der `in`-Operator
-----------------

\index{in (Operator)}
\index{Operator!in}
\index{boolescher Operator}
\index{Operator!boolescher}

Das Schlüsselwort `in` ist ein boolescher Operator, der zwei Zeichenketten annimmt und `True` zurückgibt, wenn die erste Zeichenkette als Teilzeichenkette in der zweiten erscheint:

~~~~ {.python}
>>> 'a' in 'banana'
True
>>> 'seed' in 'banana'
False
~~~~

Vergleich von Zeichenketten
---------------------------

\index{Zeichenkette!Vergleich}
\index{Vergleich!Zeichenkette}

Die Vergleichsoperatoren arbeiten mit Zeichenketten. Um zu sehen, ob zwei Zeichenketten gleich sind:

~~~~ {.python}
if word == 'banana':
    print('All right, bananas.')
~~~~ 

Andere Vergleichsoperationen sind nützlich, um Wörter in alphabetische Reihenfolge zu bringen:

~~~~ {.python}
if word < 'banana':
    print('Your word,' + word + ', comes before banana.')
elif word > 'banana':
    print('Your word,' + word + ', comes after banana.')
else:
    print('All right, bananas.')
~~~~

Python geht mit Groß- und Kleinbuchstaben nicht so um, wie es Menschen tun. Alle Großbuchstaben kommen vor allen Kleinbuchstaben, also:

~~~~
Your word, Pineapple, comes before banana.
~~~~

Eine gängige Methode, dieses Problem zu beheben, besteht darin, Zeichenketten in ein Standardformat zu konvertieren, z. B. in Kleinbuchstaben, bevor der Vergleich durchgeführt wird.

Funktionen von Zeichenketten
----------------------------

Zeichenketten sind ein Beispiel für *Objekte* in Python. Ein Objekt enthält sowohl Daten (in diesem Beispiel die eigentliche Zeichenkette selbst) als auch sogenannte *Methoden*, also Funktionen, die in das Objekt eingebaut sind und jeder *Instanz* des Objekts zur Verfügung stehen.

Python hat eine Funktion namens `dir`, die die verfügbaren Methoden für ein Objekt auflistet. Die Funktion `type` zeigt den Typ eines Objekts und die Funktion `dir` seine Methoden.

~~~~ {.python}
>>> stuff = 'Hello world'
>>> type(stuff)
<class 'str'>
>>> dir(stuff)
['capitalize', 'casefold', 'center', 'count', 'encode',
'endswith', 'expandtabs', 'find', 'format', 'format_map',
'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit',
'isidentifier', 'islower', 'isnumeric', 'isprintable',
'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower',
'lstrip', 'maketrans', 'partition', 'replace', 'rfind',
'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip',
'split', 'splitlines', 'startswith', 'strip', 'swapcase',
'title', 'translate', 'upper', 'zfill']
>>> help(str.capitalize)
Help on method_descriptor:

capitalize(...)
    S.capitalize() -> str

    Return a capitalized version of S, i.e. make the first character
    have upper case and the rest lower case.
>>>
~~~~

Während die Funktion `dir` die Methoden auflistet und man `help` verwenden kann, um eine einfache Dokumentation zu einer Methode zu erhalten, wäre eine bessere Quelle für die Dokumentation von String-Methoden <https://docs.python.org/library/stdtypes.html#string-methods>.

Der Aufruf einer *Methode* ist ähnlich wie der Aufruf einer Funktion (sie nimmt Argumente entgegen und gibt einen Wert zurück), aber die Syntax ist anders. Wir rufen eine Methode auf, indem wir den Methodennamen an den Variablennamen anhängen und den Punkt als Begrenzer verwenden.

Zum Beispiel nimmt die Methode `upper` eine Zeichenkette entgegen und gibt eine neue Zeichenkette zurück, die nur aus Großbuchstaben besteht:

\index{Methode}
\index{Zeichenkette!Methode}

Anstelle der Funktionssyntax `upper(word)` wird die Methodensyntax `word.upper()` verwendet.

\index{Punktnotation}

~~~~ {.python}
>>> word = 'banana'
>>> new_word = word.upper()
>>> print(new_word)
BANANA
~~~~

Diese Form der Punktschreibweise gibt den Namen der Methode (`upper`) und den Namen der Zeichenkette (`word`), auf die die Methode angewendet werden soll an. Die leeren Klammern zeigen an, dass diese Methode kein Argument benötigt.

\index{Klammern!leer}

Ein Methodenaufruf wird als *Aufruf* bezeichnet; in diesem Fall würden wir sagen, dass wir `upper` auf `word` aufrufen.

\index{Aufruf einer Methode}

Es gibt beispielsweise eine Zeichenketten-Methode namens `find`, die nach der Position einer Zeichenkette innerhalb einer anderen sucht:

~~~~ {.python}
>>> word = 'banana'
>>> index = word.find('a')
>>> print(index)
1
~~~~ 

In diesem Beispiel rufen wir `find` auf `word` auf und übergeben den gesuchten Buchstaben als Parameter.

Die Methode `find` kann sowohl Teilzeichenketten als auch Zeichen finden:

~~~~ {.python}
>>> word.find('na')
2
~~~~

Sie kann als zweites Argument den Index annehmen, bei dem sie beginnen soll:

\index{optionales Argument}
\index{Argument!optional}

~~~~ {.python}
>>> word.find('na', 3)
4
~~~~

Eine häufige Aufgabe ist das Entfernen von Whitespaces (Leerzeichen, Tabulatoren oder Zeilenumbrüche) am Anfang und Ende einer Zeichenkette mit der Methode `strip`:

~~~~ {.python}
>>> line = '  Here we go  '
>>> line.strip()
'Here we go'
~~~~

Einige Methoden wie `startswith` geben boolesche Werte zurück.

~~~~ {.python}
>>> line = 'Have a nice day'
>>> line.startswith('Have')
True
>>> line.startswith('h')
False
~~~~

Man kann feststellen, dass `startswith` Groß- und Kleinschreibung unterscheidet, daher nehmen wir manchmal eine Zeile und wandeln mit `lower` alles in Kleinbuchstaben um, bevor wir eine Überprüfung mit der Methode `startswith` durchführen.

~~~~ {.python}
>>> line = 'Have a nice day'
>>> line.startswith('h')
False
>>> line.lower()
'have a nice day'
>>> line.lower().startswith('h')
True
~~~~

Im letzten Beispiel wird die Methode `lower` aufgerufen und dann wird mit `startswith` geprüft, ob die resultierende klein geschriebene Zeichenkette mit dem Buchstaben „h“ beginnt. Solange wir mit der Reihenfolge vorsichtig sind, können wir mehrere Methodenaufrufe in einem einzigen Ausdruck machen.

\index{count (Methode)}
\index{Methode!count}

**Übung 4: Es gibt eine String-Methode namens `count`, die der Funktion in der vorherigen Übung ähnlich ist. Lesen Sie die Dokumentation zu dieser Methode unter:**

<https://docs.python.org/library/stdtypes.html#string-methods> 

**Schreiben Sie ein Programm, das die Anzahl der Vorkommen des Buchstabens „a“ in „banana“ mithilfe der count-Methode zählt.**

Parsen von Zeichenketten
------------------------

Oft wollen wir in eine Zeichenkette schauen und eine Teilzeichenkette finden. Wenn wir zum Beispiel eine Liste von Zeilen erhalten, die wie folgt formatiert sind:

`From stephen.marquard@`*` uct.ac.za`*` Sat Jan  5 09:14:16 2008`

Wollten wir nur die zweite Hälfte der Adresse (d.h. `uct.ac.za`) aus jeder Zeile extrahieren, können wir dies mit der Methode `find` und String-Slicing erreichen.

Zuerst wird die Position des at-Zeichens in der Zeichenkette ermittelt. Dann werden wir die Position des ersten Leerzeichens *nach* dem at-Zeichen finden. Und dann verwenden wir String-Slicing, um den Teil der Zeichenkette zu extrahieren, den wir suchen.

~~~~ {.python}
>>> data = 'From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008'
>>> atpos = data.find('@')
>>> print(atpos)
21
>>> sppos = data.find(' ',atpos)
>>> print(sppos)
31
>>> host = data[atpos+1:sppos]
>>> print(host)
uct.ac.za
>>>
~~~~

Wir verwenden eine Version der Methode `find`, die es uns erlaubt, eine Position in der Zeichenkette anzugeben, an der `find` mit der Suche beginnen soll. Dann extrahieren wir die Teilzeichenkette beginnen nach dem at-Zeichen bis hin (aber nicht einschließlich) zum Leerzeichen.

Die Dokumentation für die Methode `find` ist verfügbar unter

<https://docs.python.org/library/stdtypes.html#string-methods>.

Formatierungsoperator
---------------------

\index{Formatierungsoperator}
\index{Operator!Formatierung}

Mit dem *Formatierungsoperator* `%` können wir Zeichenketten konstruieren, wobei Teile der Zeichenketten durch die in Variablen gespeicherten Daten ersetzt werden. Wenn er auf Ganzzahlen angewendet wird, ist `%` der Modulo-Operator. Aber wenn der erste Operand eine Zeichenkette ist, ist `%` der Formatierungsoperator.

\index{Format-String}

Der erste Operand ist der *Format-String*, der ein oder mehrere *Formatierungszeichen* enthält, die angeben, wie der zweite Operand formatiert wird. Das Ergebnis ist eine Zeichenkette.

\index{Formatierungszeichen}

Zum Beispiel bedeutet das Formatierungszeichen `%d`, dass der zweite Operand als Ganzzahl formatiert werden soll (`d` steht für „decimal“):

~~~~ {.python}
>>> camels = 42
>>> '%d' % camels
'42'
~~~~

Das Ergebnis ist die Zeichenkette `'42'`, die nicht zu verwechseln ist mit dem Ganzzahlwert 42.

Ein Formatierungszeichen kann an beliebiger Stelle im Format-String erscheinen, sodass wir zum Beispiel einen Wert in einen Satz einfügen können:

~~~~ {.python}
>>> camels = 42
>>> 'I have spotted %d camels.' % camels
'I have spotted 42 camels.'
~~~~

Wenn der Format-String mehr als ein Formatierungszeichen enthält, muss das zweite Argument ein Tupel sein^[Ein Tupel ist eine Folge von durch Kommata getrennten Werten innerhalb eines Paares runder Klammern. Wir werden Tupel in Kapitel 10 behandeln]. Jedes Formatierungszeichen wird der Reihe nach mit einem Element des Tupels abgeglichen.

Das folgende Beispiel verwendet `%d` zur Formatierung einer Ganzzahl, `%g` zur Formatierung einer Fließkommazahl und `%s` zur Formatierung einer Zeichenkette:

~~~~ {.python}
>>> 'In %d years I have spotted %g %s.' % (3, 0.1, 'camels')
'In 3 years I have spotted 0.1 camels.'
~~~~

Die Anzahl der Elemente im Tupel muss mit der Anzahl der Formatierungszeichen im Format-String übereinstimmen. Auch die Typen der Elemente müssen mit den Formatierungszeichen übereinstimmen:

\index{Ausnahme!TypeError}
\index{TypeError}

~~~~ {.python}
>>> '%d %d %d' % (1, 2)
TypeError: not enough arguments for format string
>>> '%d' % 'dollars'
TypeError: %d format: a number is required, not str
~~~~

Im ersten Beispiel sind nicht genügend Argumente im Tupel vorhanden, im zweiten Beispiel ist das Argument vom falschen Typ.

Der Format-Operator ist mächtig, aber er kann schwierig zu bedienen sein. Mehr darüber kann man unter

<https://docs.python.org/library/stdtypes.html#printf-style-string-formatting> lesen.

Debugging
---------

\index{Debugging}

Eine Fähigkeit, die man beim Programmieren kultivieren sollte, ist, sich immer zu fragen: „Was könnte hier schiefgehen?“ oder alternativ: „Welche verrückte Sache könnte unser Benutzer tun, um unser (scheinbar) perfektes Programm zum Absturz zu bringen?“.

Schauen wir uns zum Beispiel das Programm an, das wir zur Demonstration der `while`-Schleife im Kapitel über Iteration verwendet haben:

\VerbatimInput{../code3/copytildone2.py}

Beobachten wir, was passiert, wenn der Benutzer eine leere Eingabezeile eingibt:

~~~~ {.python}
> hello there
hello there
> # don't print this
> print this!
print this!
>
Traceback (most recent call last):
  File "copytildone.py", line 3, in <module>
    if line[0] == '#':
IndexError: string index out of range
~~~~

Der Programm funktioniert gut, bis ihm eine leere Zeile präsentiert wird. Dann gibt es kein Zeichen an der nullten Indexposition, also erhalten wir einen Traceback. Es gibt zwei Lösungen, um Zeile drei „sicher“ zu machen, auch wenn die Zeichenkette leer ist.

Eine Möglichkeit ist, einfach die Methode `startswith` zu verwenden, die `False` zurückgibt, wenn die Zeichenkette leer ist.

~~~~ {.python}
if line.startswith('#'):
~~~~

\index{Wächter-Muster}
\index{Muster!Wächter}

Eine andere Möglichkeit ist, die `if`-Anweisung mit einem „Wächter“ abzusichern und sicherzustellen, dass der zweite logische Ausdruck nur ausgewertet wird, wenn mindestens ein Zeichen in der Zeichenkette vorhanden ist:

~~~~ {.python}
if len(line) > 0 and line[0] == '#':
~~~~

Glossar
-------

Schleifenzähler
:   Eine Variable, die zum Zählen von etwas verwendet wird und normalerweise mit 0 initialisiert ist und dann inkrementiert wird.
\index{Schleifenzähler}

leere Zeichenkette
:   Eine Zeichenkette ohne Zeichen und mit der Länge 0, dargestellt durch zwei Anführungszeichen.
\index{leere Zeichenkette}

Formatierungsoperator
:   Der Operator `%`, der einen Format-String und ein Tupel entgegennimmt und eine Zeichenkette erzeugt, die die Elemente des Tupels enthält, die gemäß des Format-Strings formatiert sind.
\index{Formatierungsoperator}
\index{Operator!Formatierung}

Formatierungszeichen
:   Ein Zeichen in einem Format-String, z. B. `%d`, das angibt, wie ein Wert formatiert werden soll.
\index{Formatierungszeichen}

Format-String
:   Eine Zeichenkette, die mit dem Formatierungsoperator verwendet wird und Formatierungszeichen enthält.
\index{Format-String}

Flag
:   Eine boolesche Variable, die anzeigt, ob eine Bedingung wahr oder falsch ist.
\index{Flag}

Aufruf einer Methode
:   Eine Anweisung, die eine Methode aufruft.
\index{Aufruf einer Methode}

Unveränderlichkeit
:   Die Eigenschaft einer Sequenz, deren Elemente nicht verändert werden können.
\index{Unveränderlichkeit}

Index
:   Ein ganzzahliger Wert, der verwendet wird, um ein Element in einer Sequenz auszuwählen, z. B. ein Zeichen in einer Zeichenkette.
\index{Index}
\index{}

Element
:   Einer der Werte in einer Sequenz.
\index{Element}

Methode
:   Eine Funktion, die mit einem Objekt verknüpft ist und in Punktschreibweise aufgerufen wird.
\index{Methode}

Objekt
:   Etwas, auf das sich eine Variable beziehen kann. Im Moment können wir „Objekt“ und „Wert“ noch austauschbar verwenden.
\index{Objekt}

Suche
:   Ein Muster, das beim Traversieren durch eine Zeichenkette dafür sorgt, dass die Suche beendet wird, sobald die gesuchte Teilzeichenkette gefunden wurde.
\index{Suchmuster}
\index{Muster!Suche}

Folge
:   Eine geordnete Menge, d. h. eine Menge von Werten, bei der jeder Wert durch einen ganzzahligen Index gekennzeichnet ist.
\index{Folge}

Teilzeichenkette
:   Ein Teil einer Zeichenkette, der durch einen Bereich von Indizes angegeben wird.
\index{Teilzeichenkette}

Traversieren
:   Durch die Elemente einer Sequenz iterieren und für jedes Element eine ähnliche Operation ausführen.
\index{Traversieren}

Übungen
-------

**Übung 5: Nehmen Sie den folgenden Python-Code, der eine Zeichenkette speichert:**

`str = 'X-DSPAM-Confidence: `**`0.8475`**`'`

**Verwenden Sie `find` und String-Slicing, um den Teil der Zeichenkette nach dem Doppelpunkt zu extrahieren, und verwenden Sie dann die Funktion `float`, um die extrahierte Teilzeichenkette in eine Fließkommazahl zu konvertieren.**

\index{Zeichenkette!Methode}
\index{Methode!Zeichenkette}

**Übung 6: Lesen Sie die Dokumentation der String-Methoden unter <https://docs.python.org/library/stdtypes.html#string-methods>. Vielleicht möchten Sie mit einigen von ihnen experimentieren, um sicherzustellen, dass Sie verstehen, wie sie funktionieren. `strip` und `replace` sind besonders nützlich.**

**Die Dokumentation verwendet eine Syntax, die verwirrend sein kann. Zum Beispiel in `find(sub[, start[, end]])` zeigen die Klammern optionale Argumente an. Also ist `sub` erforderlich, aber `start` ist optional, und wenn Sie `start` verwenden, dann ist `end` wiederum optional.**

